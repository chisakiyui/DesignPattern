                                    常用设计模式

工厂方法模式、简单工厂模式、抽象工厂模式、静态代理模式、jdk动态代理、
cglib动态代理、策略模式、模板模式、装饰器模式、观察者模式

=========================================================================================
                                    factory-工厂方法模式
/**
 * 工厂方法模式
 * 符合开闭原则
 * 如果想新增一种Shape,只需要新增具体实现类以及该生产类的工厂（新增具体产品和对应的具体工厂）
 * 不需要修改任何其他代码
 *
 * 具体工厂实现抽象工厂
 * 具体产品实现抽象产品
 * 在使用中：抽象工厂根据客户端需求生成具体的产品
 *
 */
=========================================================================================
                                 simplefactory-简单工厂模式

=========================================================================================
                                 staticproxy-静态代理模式
/**
 * Main
 *
 * 代理模式这种设计模式是一种使用代理对象来执行目标对象的方法并
 * 在代理对象中增强目标对象方法的一种设计模式。代理对象代为执行
 * 目标对象的方法，并在此基础上进行相应的扩展。
 *
 * 降低了系统的耦合度
 * 代理对象可以在客户端和目标对象间起到中介的作用，起到了保护目标对象的作用
 * 可以扩展目标对象的功能
 *
 * Spring的AOP机制就是采用动态代理的机制来实现切面编程的
 *
 * 这里是静态代理
 * 优点：
 * 可以做到在不修改目标对象的功能前提下，对目标功能扩展
 * 缺点：
 * 因为代理对象需要与目标对象实现一样的接口，所有会有很多代理类，类太多，同时，一旦接口新增了方法，目标对象与代理对象都要维护
 * 为了解决这一个缺点，可以使用动态代理方式
 */
=========================================================================================
                            jdkdynamicproxy-jdk动态代理
/**
 * Main
 *
 * 动态代理模式
 *
 * 代理对象是由jvm生成的，不像静态代理，需要自己new一个代理对象出来
 * 生成的代理对象也实现了目标对象实现的接口
 * 因为这个代理对象是jdk相关代码生成的，所以这个称为jdk动态代理
 * 局限性：要求目标对象必须实现一个接口，为了解决这个问题，有了cglib动态代理
 */
=========================================================================================
                            cglibproxy-cglib动态代理
/**
 * Main
 *
 * cglib动态代理
 *
 * 相比jdk的模式，cglib少一个接口类，
 * 因为cglib返回的代理对象是目标对象的子类，
 * 而jdk产生的代理对象和目标对象都实现了一个公共接口
 *
 * 在运行时期，cglib会生成被代理对象的子类，并重写被代理对象的所有方法，从而作为代理对象
 * 所以：
 * 需要注意的是用final修饰的目标类，是不能生成代理子类的
 *
 * 应用：
 * 对一个类的所有方法做日志处理
 * 扩展原有功能，符合开闭原则，没有对目标类做任何修改
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
=========================================================================================
                                strategy-策略模式
/**
 * Main
 * <p>
 * 策略模式属于对象的行为模式
 * 针对一组算法，将每一个算法封装在具有共同接口的独立的类中，
 * 从而使得它们可以相互替换
 * <p>
 * 涉及到三个角色：
 * 1.环境角色 Context
 * 2.抽象策略角色
 * 3.具体策略角色
 */
=========================================================================================
                                prototype-原型模式

=========================================================================================
                                template-模板模式

=========================================================================================
                                decorator-装饰器模式
装饰器模式涉及到的角色：
1.被装饰的对象（具体类，需要实现一个接口）；
2.装饰器（实现和被装饰类同样的接口，并持有这个接口的一个引用）；
3.接口（最好这个接口后续不要改动，维护成本比较高）；
4.具体装饰器（继承上面的装饰器，增强接口功能）；
=========================================================================================
                                observer-观察者模式
/**
 * Main
 *
 * 观察者模式
 *
 * 多个对象间存在一对多的依赖关系
 * 当一个对象的状态发生改变时
 * 所有依赖它的对象都得到通知并自动更新
 *
 * 降低了目标和观察者之间的耦合关系
 *
 * 注意目标对象和具体观察者对象之间不能直接调用，否则将使两者紧密耦合起来
 *
 * 主要角色：抽象主题角色、具体主题角色、抽象观察者角色、具体观察者角色
 */
=========================================================================================